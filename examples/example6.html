<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Example 6</title>
        <meta name="author" content="Daniel Torres">
        <meta name="description" content="Example of Simplicial Polyhedron with movement">
        <link href="css/main.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/94/three.min.js"></script>
        <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
        <script src="../simplicialPolyhedron.js"></script>
        <script src="js/sceneManager.js"></script>

        <script>

            /*
            *
            *   Setup Scene
            *
            * */

            const sceneManager = new SceneManager();
            sceneManager
                .registerScene('main scene', function(scene) {
                    // set up some light...
                    const light = new THREE.AmbientLight( 0x404040 )
                    scene.add( light )
                })
                .registerCamera('main camera',{}, function(camera) {
                    const R = 5
                    const theta = 0.5/4 * 2 * Math.PI
                    camera.position.set(0,-R * Math.cos(theta), R * Math.sin(theta))
                    camera.lookAt(0,0,0)
                })

            const controls =  new THREE.OrbitControls( sceneManager.getCurrentCamera() )
            sceneManager
                .registerStep('update orbit controls', (t,scene,camera) => {
                    controls.update()
                })



            /*
             *
             * Simplicial complex
             *
             * */

            // tools
            const module2 = a => a[0]*a[0] + a[1]*a[1] + a[2]*a[2]
            const module = a => Math.sqrt(module2(a))
            const d2 = (a,b) => (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2])
            const d = (a,b) => Math.sqrt(d2(a,b))
            const clear = a => {
                a[0] = 0;
                a[1] = 0;
                a[2] = 0;
                return a
            }
            const add = (a,b) => {
                a[0] += b[0];
                a[1] += b[1];
                a[2] += b[2];
                return a
            }
            const subs = (a,b) => {
                a[0] -= b[0];
                a[1] -= b[1];
                a[2] -= b[2];
                return a
            }
            const mult = (lambda,a) => {
                a[0] *= lambda;
                a[1] *= lambda;
                a[2] *= lambda;
                return a
            }
            const addMult = (a,lambda,b) => {
                a[0] += lambda * b[0];
                a[1] += lambda * b[1];
                a[2] += lambda * b[2];
                return a
            }
            const getMult = (lambda,a) => [
                a[0] * lambda,
                a[1] * lambda,
                a[2] * lambda,
            ]
            const getDiff = (a,b) => [
                a[0] - b[0],
                a[1] - b[1],
                a[2] - b[2],
            ]


            SimplicialPolyhedron.THREE = THREE;

            // define cyclic curve with period 1
            const R = 1
            const n = 16
            const s2 = new SimplicialPolyhedron.Disc(n,32,R)

            // build dynamics
            const dynamics = new (function Dynamics (p) {

                const l = p.length(0)
                let lastT = null
                const neighbors = new Array(l)
                const physics = new Array(l)
                const g = [0,0,-9.8]
                const K = n*100 // elasticity constant
                const mu = 0.4 // friction constant

                const velocities = new Float32Array(3*l)
                const accelerations = new Float32Array(3*l)

                const floor = -10000

                p.forEachPoint( (x,point) => {
                    neighbors[point] = {
                        targets: [],
                        restDistances: [],
                    }

                    physics[point] = {
                        x: p.coordinates.subarray(3*point,3*point+3),
                        dx: velocities.subarray(3*point,3*point+3),
                        ddx: accelerations.subarray(3*point,3*point+3),
                        mass: 1/l,
                        fixed: module2(x) >= 0.9*R*R
                    }
                })

                p.forEachMaximalSimplex( face => {
                    for (let i = 0; i < face.length; i++) {
                        for (let j = 0; j < face.length; j ++) {
                            if ( i !== j) {
                                let k = neighbors[face[i]].targets.findIndex( neighbor => neighbor === face[j])
                                if (k < 0) {
                                    neighbors[face[i]].targets.push(face[j])
                                    neighbors[face[i]].restDistances.push(d(physics[face[i]].x,physics[face[j]].x))

                                }
                            }
                        }
                    }
                })

                const updateForces = function (dt) {
                    physics.forEach ( (physic,i) => {
                        clear(physic.ddx)

                        if (physic.fixed) {
                            return
                        }

                        // gravity
                        add(physic.ddx,g)

                        // neighbors
                        neighbors[i].targets.forEach( (j, k) => {
                            const dir = getDiff(physics[j].x,physic.x)
                            const l = module(dir)
                            addMult( physic.ddx,K*(l - neighbors[i].restDistances[k])/l,dir)
                        })

                        // force to acc
                        mult(1/physic.mass,physic.ddx)

                        // floor
                        if (physic.x[2] <= floor) {
                            physic.ddx[2] = 0
                        }
                    })
                }

                const updateVelocities = function (dt) {
                    physics.forEach( (physic,i) => {
                        addMult(physic.dx,dt,physic.ddx)

                        // friction
                        addMult(physic.dx,-mu*physic.mass,physic.dx)


                        // floor
                        if (physic.x[2] <= floor) {
                            physic.dx[2] *= -1
                        }
                    })
                }

                const updatePositions = function (dt) {
                    physics.forEach( (physic,i) => {
                        addMult(physic.x,dt,physic.dx)

                        // floor
                        if (physic.x[2] <= floor) {
                            physic.x[2] = floor
                        }
                    })
                }

                this.update = function (t) {
                    if (lastT !== null ) {
                      let dt = t - lastT
                      ;
                      dt *= 2/l
                      updateForces(dt)
                      updateVelocities(dt)
                      updatePositions(dt)
                    }

                    lastT = t
                    p.updateGeometry()
                    return this
                }

            })(s2)

            // update physics
            sceneManager.registerStep('update polyhedron', t => {
                dynamics.update(t)
            })


            // build and get buffer geometry
            const geometry = s2.geometry
            const material = new THREE.MeshNormalMaterial({
                side: THREE.DoubleSide,
            })
            const mesh = new THREE.Mesh(geometry,material)

            sceneManager.getCurrentScene().add(mesh)


            // add step to schedule
            sceneManager.schedule = [
                'update orbit controls',
                'update polyhedron',
            ]

            sceneManager.start()


        </script>
    </body>
</html>